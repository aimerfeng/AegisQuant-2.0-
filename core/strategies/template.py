"""
Titan-Quant Strategy Template

This module provides the base template class for trading strategies.
All user strategies should inherit from CtaTemplate and implement
the required lifecycle methods.

Requirements:
    - 8.6: THE Strategy_Lab SHALL 提供策略模板（继承 CtaTemplate），
           包含标准生命周期方法
"""
from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Set, Type

from core.engine.types import BarData, TickData, OrderData, Direction, Offset


class StrategyStatus(Enum):
    """Strategy execution status."""
    IDLE = "idle"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


@dataclass
class TradeSignal:
    """
    Trade signal generated by a strategy.
    
    Attributes:
        symbol: Trading symbol
        direction: Trade direction (LONG/SHORT)
        offset: Trade offset (OPEN/CLOSE)
        price: Target price (0 for market order)
        volume: Trade volume
        signal_time: When the signal was generated
        reason: Reason for the signal
    """
    symbol: str
    direction: Direction
    offset: Offset
    price: float
    volume: float
    signal_time: datetime = field(default_factory=datetime.now)
    reason: str = ""


# Decorator for marking variables to preserve during selective hot reload
def preserve(func_or_attr: Any) -> Any:
    """
    Decorator to mark a method or attribute for preservation during hot reload.
    
    When using SELECTIVE hot reload policy, only methods and attributes
    marked with @preserve will retain their values/state.
    
    Can be used on methods:
        @preserve
        def calculate_indicator(self):
            ...
    
    Or as a marker in __init__:
        def __init__(self):
            self._preserve_vars = {'position', 'entry_price'}
    
    Example:
        class MyStrategy(CtaTemplate):
            @preserve
            def on_bar(self, bar: BarData):
                # This method's internal state will be preserved
                pass
    """
    if callable(func_or_attr):
        func_or_attr._preserve = True
        return func_or_attr
    return func_or_attr


class CtaTemplate(ABC):
    """
    CTA Strategy Template Base Class.
    
    This is the base class for all CTA (Commodity Trading Advisor) strategies.
    Strategies should inherit from this class and implement the required
    lifecycle methods.
    
    Lifecycle Methods:
        - on_init(): Called when strategy is initialized
        - on_start(): Called when strategy starts running
        - on_stop(): Called when strategy stops
        - on_tick(tick): Called on each tick update
        - on_bar(bar): Called on each bar update
        - on_order(order): Called when order status changes
        - on_trade(trade): Called when a trade is executed
    
    Parameters:
        Define strategy parameters in the 'parameters' class attribute.
        These will be automatically mapped to UI widgets.
    
    Example:
        class MACrossStrategy(CtaTemplate):
            # Strategy parameters - automatically mapped to UI
            parameters = {
                "fast_period": {"default": 10, "min": 1, "max": 100, "widget": "slider"},
                "slow_period": {"default": 20, "min": 1, "max": 200, "widget": "slider"},
                "volume": {"default": 1.0, "min": 0.1, "max": 100.0},
            }
            
            def on_init(self):
                self.fast_ma = []
                self.slow_ma = []
                self.position = 0
            
            def on_bar(self, bar: BarData):
                # Strategy logic here
                pass
    """
    
    # Strategy parameters - override in subclass
    # Format: {"param_name": default_value} or
    #         {"param_name": {"default": value, "min": min, "max": max, ...}}
    parameters: Dict[str, Any] = {}
    
    # Variables to preserve during selective hot reload
    # Override in subclass to specify which variables to preserve
    preserve_variables: Set[str] = set()
    
    def __init__(
        self,
        strategy_name: str = "",
        symbols: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> None:
        """
        Initialize the strategy template.
        
        Args:
            strategy_name: Name of the strategy instance
            symbols: List of symbols to trade
            **kwargs: Additional parameters (matched against 'parameters')
        """
        self.strategy_name = strategy_name or self.__class__.__name__
        self.symbols = symbols or []
        self.status = StrategyStatus.IDLE
        
        # Trading state
        self.positions: Dict[str, float] = {}  # symbol -> position
        self.orders: Dict[str, OrderData] = {}  # order_id -> order
        
        # Internal state
        self._inited = False
        self._trading = False
        self._signals: List[TradeSignal] = []
        
        # Apply parameters from kwargs
        for name, value in kwargs.items():
            if hasattr(self, name) or name in self.parameters:
                setattr(self, name, value)
        
        # Apply default parameters
        for name, config in self.parameters.items():
            if not hasattr(self, name):
                if isinstance(config, dict):
                    setattr(self, name, config.get("default", config.get("value")))
                else:
                    setattr(self, name, config)
    
    # ==================== Lifecycle Methods ====================
    
    def on_init(self) -> None:
        """
        Called when strategy is initialized.
        
        Override this method to perform initialization tasks such as:
        - Loading historical data
        - Initializing indicators
        - Setting up internal state
        
        This method is called once before the strategy starts.
        """
        pass
    
    def on_start(self) -> None:
        """
        Called when strategy starts running.
        
        Override this method to perform tasks when trading begins:
        - Reset counters
        - Log start message
        - Initialize trading state
        """
        self._trading = True
        self.status = StrategyStatus.RUNNING
    
    def on_stop(self) -> None:
        """
        Called when strategy stops.
        
        Override this method to perform cleanup tasks:
        - Save state
        - Close positions (optional)
        - Log stop message
        """
        self._trading = False
        self.status = StrategyStatus.STOPPED
    
    @abstractmethod
    def on_tick(self, tick: TickData) -> None:
        """
        Called on each tick update.
        
        Override this method to implement tick-level strategy logic.
        
        Args:
            tick: The tick data update
        """
        pass
    
    @abstractmethod
    def on_bar(self, bar: BarData) -> None:
        """
        Called on each bar update.
        
        Override this method to implement bar-level strategy logic.
        
        Args:
            bar: The bar data update
        """
        pass
    
    def on_order(self, order: OrderData) -> None:
        """
        Called when order status changes.
        
        Override this method to handle order updates:
        - Track order status
        - Handle rejections
        - Update internal state
        
        Args:
            order: The order update
        """
        self.orders[order.order_id] = order
    
    def on_trade(self, trade: Dict[str, Any]) -> None:
        """
        Called when a trade is executed.
        
        Override this method to handle trade execution:
        - Update position tracking
        - Calculate P&L
        - Log trade details
        
        Args:
            trade: The trade details
        """
        pass
    
    # ==================== Trading Methods ====================
    
    def buy(
        self,
        symbol: str,
        price: float,
        volume: float,
        reason: str = "",
    ) -> Optional[str]:
        """
        Submit a buy order (open long position).
        
        Args:
            symbol: Trading symbol
            price: Order price (0 for market order)
            volume: Order volume
            reason: Reason for the trade
        
        Returns:
            Order ID if submitted, None otherwise
        """
        if not self._trading:
            return None
        
        signal = TradeSignal(
            symbol=symbol,
            direction=Direction.LONG,
            offset=Offset.OPEN,
            price=price,
            volume=volume,
            reason=reason,
        )
        self._signals.append(signal)
        return f"signal_{len(self._signals)}"
    
    def sell(
        self,
        symbol: str,
        price: float,
        volume: float,
        reason: str = "",
    ) -> Optional[str]:
        """
        Submit a sell order (close long position).
        
        Args:
            symbol: Trading symbol
            price: Order price (0 for market order)
            volume: Order volume
            reason: Reason for the trade
        
        Returns:
            Order ID if submitted, None otherwise
        """
        if not self._trading:
            return None
        
        signal = TradeSignal(
            symbol=symbol,
            direction=Direction.LONG,
            offset=Offset.CLOSE,
            price=price,
            volume=volume,
            reason=reason,
        )
        self._signals.append(signal)
        return f"signal_{len(self._signals)}"
    
    def short(
        self,
        symbol: str,
        price: float,
        volume: float,
        reason: str = "",
    ) -> Optional[str]:
        """
        Submit a short order (open short position).
        
        Args:
            symbol: Trading symbol
            price: Order price (0 for market order)
            volume: Order volume
            reason: Reason for the trade
        
        Returns:
            Order ID if submitted, None otherwise
        """
        if not self._trading:
            return None
        
        signal = TradeSignal(
            symbol=symbol,
            direction=Direction.SHORT,
            offset=Offset.OPEN,
            price=price,
            volume=volume,
            reason=reason,
        )
        self._signals.append(signal)
        return f"signal_{len(self._signals)}"
    
    def cover(
        self,
        symbol: str,
        price: float,
        volume: float,
        reason: str = "",
    ) -> Optional[str]:
        """
        Submit a cover order (close short position).
        
        Args:
            symbol: Trading symbol
            price: Order price (0 for market order)
            volume: Order volume
            reason: Reason for the trade
        
        Returns:
            Order ID if submitted, None otherwise
        """
        if not self._trading:
            return None
        
        signal = TradeSignal(
            symbol=symbol,
            direction=Direction.SHORT,
            offset=Offset.CLOSE,
            price=price,
            volume=volume,
            reason=reason,
        )
        self._signals.append(signal)
        return f"signal_{len(self._signals)}"
    
    # ==================== Utility Methods ====================
    
    def get_position(self, symbol: str) -> float:
        """Get current position for a symbol."""
        return self.positions.get(symbol, 0.0)
    
    def get_signals(self) -> List[TradeSignal]:
        """Get and clear pending signals."""
        signals = self._signals.copy()
        self._signals.clear()
        return signals
    
    def is_trading(self) -> bool:
        """Check if strategy is currently trading."""
        return self._trading
    
    def get_state(self) -> Dict[str, Any]:
        """
        Get the current state of the strategy.
        
        Returns a dictionary of all non-private attributes that can be
        used for snapshot creation or state inspection.
        """
        state = {}
        for name in dir(self):
            if name.startswith('_'):
                continue
            try:
                value = getattr(self, name)
                if not callable(value):
                    state[name] = value
            except Exception:
                pass
        return state
    
    def set_state(self, state: Dict[str, Any]) -> None:
        """
        Restore strategy state from a dictionary.
        
        Args:
            state: Dictionary of attribute name to value
        """
        for name, value in state.items():
            if hasattr(self, name) and not name.startswith('_'):
                try:
                    setattr(self, name, value)
                except Exception:
                    pass


__all__ = [
    "StrategyStatus",
    "TradeSignal",
    "preserve",
    "CtaTemplate",
]
